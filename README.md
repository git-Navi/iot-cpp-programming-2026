# iot-cpp-programming-2026
IoT개발자 과정 C++

## 1일차

### 객체, 인스턴스 차이점

객체는 클래스가 있어야하며, 클래스를 일종의 타입이라고 보면 된다.
클래스를 만드는 건 하나의 사용자 정의 자료형이다.
클래스는 C언어의 구조체 같은 개념이다.

클래스는 사용자가 만든 자료형이다.

### stream 의미?

키보드, 문자열 바로 출력되는게 아니라 steram buffer에 저장된다.
cin이라는 객체가 호출이 되면 buffer에 저장되는 값을 불러오는 형태다.
값을 받고 엔터를 치는 순간 버퍼에 값과 엔터가 임시 저장된다.

stream은 일종의 buffer라고 보면 된다.

`std::cout << "이름" << std:endl;` 에서 `<<` 는 출력 스트림.
`std::cin >> name` 에서 `>>` 가 입력 스트림.

### 함수 오버로딩?

본래 C 기준으로 같은 함수 이름이 있으면 같은 함수로 취급되어 에러가 떴지만, C++은 함수 이름과 동시에 전달되는 인자 정보까지 고려를 하기 때문에 같은 함수 이름이여도 입력 부분인 인자 정보가 다르면 다르게 취급된다.

이걸 함수 오버로딩(Function Overloading)이라고 한다.

[확인](./Day-01/cppSolution/base-prac5/base-prac5.cpp)
[확인](./Day-01/cppSolution/base-prac6/base-prac6.cpp)
[확인](./Day-01/cppSolution/base-prac7/base-prac7.cpp)

### 매크로 함수 vs inline

- 기본 비교표

| 항목 | 매크로 함수 (`#define`) | `inline` 함수 |
|---|---|---|
| **처리 시점** | 전처리기 (컴파일 이전) | 컴파일러 |
| **동작 방식** | 텍스트 단순 치환 | 함수 본체를 호출 위치에 삽입 (힌트) |
| **타입 검사** | ❌ 없음 | ✅ 있음 |
| **디버깅** | ❌ 어려움 (치환된 코드 추적 불가) | ✅ 가능 (일반 함수와 동일) |
| **부작용 (Side Effect)** | ❌ 있음 (이중 평가 등) | ✅ 없음 |
| **스코프** | ❌ 없음 (전역 치환) | ✅ 일반 함수와 동일 |
| **네임스페이스** | ❌ 무시됨 | ✅ 적용됨 |
| **재귀 지원** | ❌ 불가 | ✅ 가능 (단, 인라인 처리는 무시됨) |
| **컴파일러 제어** | 강제 치환 (컴파일러 개입 없음) | 컴파일러가 최종 결정 |
| **인라인 강제 여부** | ✅ 항상 치환 | ❌ 힌트일 뿐 (무시될 수 있음) |
| **오버로딩** | ❌ 불가 | ✅ 가능 |
| **ODR 위반 방지** | ❌ 해당 없음 | ✅ 방지 가능 |
| **안전성** | ❌ 낮음 | ✅ 높음 |

---

- 코드 예시 비교

1. 매크로 함수

```cpp
#define SQUARE(x) ((x) * (x))

int i = 3;
int result = SQUARE(i++);
// → ((i++) * (i++))  ← i가 두 번 증가! 미정의 동작(UB)
```

2. inline 함수

```cpp
inline int square(int x) {
    return x * x;
}

int i = 3;
int result = square(i++);  // 안전하게 동작, i는 한 번만 증가
```

---

- 사용 목적별 권장 방식

| 목적 | 권장 방법 |
|---|---|
| 단순 상수 정의 | `const` / `constexpr` |
| 컴파일 타임 계산 | `constexpr` 함수 |
| 헤더 파일 함수 정의 (ODR 방지) | `inline` 함수 |
| 작고 자주 호출되는 함수 최적화 | `inline` 함수 (컴파일러에 위임) |
| 강제 인라인 (컴파일러 확장) | `__forceinline` (MSVC) / `__attribute__((always_inline))` (GCC/Clang) |
| 조건부 컴파일 | `#ifdef` / `#if` (매크로의 유효한 사용처) |

---

- 결론

> **매크로 함수는 타입 안전성이 없고 부작용이 발생하기 쉬워 현대 C++에서는 지양한다.**  
> 함수 목적이라면 `inline` 또는 `constexpr`을 사용하는 것이 표준적인 방식이다.